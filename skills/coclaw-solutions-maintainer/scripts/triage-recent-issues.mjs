#!/usr/bin/env node
/**
 * Triage OpenClaw issues for CoClaw Troubleshooting Solutions maintenance.
 *
 * - Reads: src/data/openclaw/openclaw-issues.json (generated by `pnpm sync:issues`)
 * - Scans existing Solutions: src/content/troubleshooting/solutions/*.mdx
 * - Prints only newly-seen issues (stateful), with best-effort matches to existing Solutions.
 * - Persists state to: .cache/coclaw-solutions-maintainer/state.json
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';

function parseArgs(argv) {
  const args = {
    sinceHours: 72,
    stateFile: path.resolve('.cache', 'coclaw-solutions-maintainer', 'state.json'),
    dryRun: false,
    includeUpdated: false,
    json: false,
  };

  for (let i = 0; i < argv.length; i += 1) {
    const a = argv[i];
    if (a === '--since-hours') {
      const v = argv[i + 1];
      i += 1;
      const n = Number.parseInt(v ?? '', 10);
      if (!Number.isFinite(n) || n <= 0) throw new Error(`Invalid --since-hours: ${v}`);
      args.sinceHours = n;
      continue;
    }
    if (a === '--state') {
      const v = argv[i + 1];
      i += 1;
      if (!v) throw new Error('Missing value for --state');
      args.stateFile = path.resolve(v);
      continue;
    }
    if (a === '--dry-run') {
      args.dryRun = true;
      continue;
    }
    if (a === '--include-updated') {
      args.includeUpdated = true;
      continue;
    }
    if (a === '--json') {
      args.json = true;
      continue;
    }
    if (a === '--help' || a === '-h') {
      console.log(`Usage:
  node skills/coclaw-solutions-maintainer/scripts/triage-recent-issues.mjs [options]

Options:
  --since-hours <n>      Only consider issues updated within the last N hours (default: 72)
  --include-updated      Include already-processed issues if updatedAt advanced since last run
  --state <path>         Override state file path (default: .cache/coclaw-solutions-maintainer/state.json)
  --dry-run              Do not write state
  --json                 Emit machine-readable JSON only
`);
      process.exit(0);
    }

    throw new Error(`Unknown arg: ${a}`);
  }

  return args;
}

async function fileExists(p) {
  try {
    await fs.stat(p);
    return true;
  } catch {
    return false;
  }
}

function extractFrontmatterBlock(src) {
  const m = src.match(/^---\n([\s\S]*?)\n---\n/m);
  return m?.[1] ?? '';
}

function extractScalar(yaml, key) {
  // key: "value" | key: value
  const re = new RegExp(`^${key}:\\s*(.+?)\\s*$`, 'm');
  const m = yaml.match(re);
  if (!m) return null;
  let v = m[1].trim();
  if ((v.startsWith('"') && v.endsWith('"')) || (v.startsWith("'") && v.endsWith("'"))) {
    v = v.slice(1, -1);
  }
  return v;
}

function extractList(yaml, key) {
  // Supports:
  // key: ["a", "b"]
  // key:
  //   - a
  //   - "b"
  const lines = yaml.split('\n');
  const idx = lines.findIndex((l) => l.startsWith(`${key}:`));
  if (idx === -1) return [];

  const first = lines[idx].slice(`${key}:`.length).trim();
  if (first.startsWith('[')) {
    const inside = first.replace(/^\[/, '').replace(/\]\s*$/, '');
    return inside
      .split(',')
      .map((s) => s.trim())
      .filter(Boolean)
      .map((s) => s.replace(/^["']/, '').replace(/["']$/, ''))
      .filter(Boolean);
  }

  /** @type {string[]} */
  const out = [];
  for (let i = idx + 1; i < lines.length; i += 1) {
    const l = lines[i];
    if (!l.startsWith(' ') && /^[a-zA-Z0-9_-]+:/.test(l)) break;
    const m = l.match(/^\s*-\s*(.+?)\s*$/);
    if (!m) continue;
    out.push(m[1].trim().replace(/^["']/, '').replace(/["']$/, ''));
  }
  return out.filter(Boolean);
}

function tokenize(s) {
  const STOP = new Set([
    'error',
    'errors',
    'fail',
    'fails',
    'failed',
    'failure',
    'issue',
    'issues',
    'bug',
    'fix',
    'fixed',
    'cannot',
    'unable',
    'when',
    'after',
    'before',
    'during',
    'with',
    'without',
    'from',
    'into',
    'this',
    'that',
    'does',
    'doesnt',
    'dont',
    'wont',
    'your',
    'their',
    'then',
    'than',
    'been',
  ]);

  return s
    .toLowerCase()
    .split(/[^a-z0-9]+/g)
    .map((t) => t.trim())
    .filter((t) => t.length >= 4 && !STOP.has(t))
    .slice(0, 12);
}

function scoreSolutionMatch(issueTextLower, sol) {
  let sigHits = 0;
  let slugHits = 0;
  let titleHits = 0;

  for (const sig of sol.errorSignatures) {
    const sigLower = sig.toLowerCase();
    if (!sigLower) continue;
    if (issueTextLower.includes(sigLower)) sigHits += 1;
  }

  for (const token of sol.titleTokens) {
    if (issueTextLower.includes(token)) titleHits += 1;
  }

  for (const token of sol.slugTokens) {
    if (issueTextLower.includes(token)) slugHits += 1;
  }

  const score = sigHits * 20 + slugHits * 4 + titleHits * 1;
  return { score, sigHits, slugHits, titleHits };
}

async function loadSolutionsIndex(repoRoot) {
  const solutionsDir = path.join(repoRoot, 'src', 'content', 'troubleshooting', 'solutions');

  /** @type {{slug: string, filePath: string, title: string, errorSignatures: string[], titleTokens: string[]}[]} */
  const out = [];

  let entries = [];
  try {
    entries = await fs.readdir(solutionsDir, { withFileTypes: true });
  } catch {
    return out;
  }

  for (const ent of entries) {
    if (!ent.isFile()) continue;
    if (!ent.name.endsWith('.mdx')) continue;
    const filePath = path.join(solutionsDir, ent.name);
    const slug = ent.name.replace(/\.mdx$/, '');
    const src = await fs.readFile(filePath, 'utf8');
    const fm = extractFrontmatterBlock(src);
    const title = extractScalar(fm, 'title') ?? slug;
    const errorSignatures = extractList(fm, 'errorSignatures');
    const slugTokens = slug
      .split('-')
      .map((t) => t.trim())
      .filter((t) => t.length >= 5);
    out.push({
      slug,
      filePath,
      title,
      errorSignatures,
      titleTokens: tokenize(title),
      slugTokens,
    });
  }

  return out;
}

async function loadState(stateFile) {
  try {
    const raw = await fs.readFile(stateFile, 'utf8');
    const json = JSON.parse(raw);
    return {
      lastRunAt: typeof json?.lastRunAt === 'string' ? json.lastRunAt : null,
      processed: typeof json?.processed === 'object' && json?.processed ? json.processed : {},
    };
  } catch {
    return { lastRunAt: null, processed: {} };
  }
}

async function saveState(stateFile, state) {
  await fs.mkdir(path.dirname(stateFile), { recursive: true });
  await fs.writeFile(stateFile, JSON.stringify(state, null, 2) + '\n', 'utf8');
}

function issueToText(issue) {
  const comments = Array.isArray(issue.commentsData)
    ? issue.commentsData.map((c) => c?.body ?? '').join('\n')
    : '';
  return `${issue.title ?? ''}\n${issue.body ?? ''}\n${comments}`;
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const repoRoot = process.cwd();

  const issuesFile = path.join(repoRoot, 'src', 'data', 'openclaw', 'openclaw-issues.json');
  if (!(await fileExists(issuesFile))) {
    throw new Error(
      `Missing issues dataset: ${issuesFile}\nRun: OPENCLAW_ISSUES_SINCE_HOURS=72 pnpm sync:issues`
    );
  }

  const rawIssues = JSON.parse(await fs.readFile(issuesFile, 'utf8'));
  const issues = Array.isArray(rawIssues?.issues) ? rawIssues.issues : [];

  const state = await loadState(args.stateFile);
  const solutions = await loadSolutionsIndex(repoRoot);

  const cutoff = new Date(Date.now() - args.sinceHours * 60 * 60 * 1000);
  const cutoffIso = cutoff.toISOString();

  const recent = issues.filter((i) => {
    const updatedAt = typeof i?.updatedAt === 'string' ? i.updatedAt : null;
    if (!updatedAt) return false;
    // ISO strings are lexicographically comparable
    return updatedAt >= cutoffIso;
  });

  const newlySeen = recent.filter((i) => {
    const n = String(i.number);
    const prev = state.processed?.[n] ?? null;
    if (!prev) return true;
    if (!args.includeUpdated) return false;
    const updatedAt = typeof i.updatedAt === 'string' ? i.updatedAt : '';
    return updatedAt > String(prev);
  });

  newlySeen.sort((a, b) => String(b.updatedAt ?? '').localeCompare(String(a.updatedAt ?? '')));

  const out = newlySeen.map((issue) => {
    const issueTextLower = issueToText(issue).toLowerCase();
    const matches = solutions
      .map((sol) => ({
        slug: sol.slug,
        title: sol.title,
        ...scoreSolutionMatch(issueTextLower, sol),
        url: `https://coclaw.com/troubleshooting/solutions/${sol.slug}/`,
        filePath: sol.filePath,
      }))
      // "Strong match" only:
      // - errorSignatures hit (high confidence), OR
      // - at least 2 slug-token hits (still fairly specific)
      .filter((m) => m.sigHits > 0 || m.slugHits >= 2)
      .sort((a, b) => b.score - a.score)
      .slice(0, 3);

    return {
      number: issue.number,
      title: issue.title ?? '',
      htmlUrl: issue.htmlUrl ?? null,
      updatedAt: issue.updatedAt ?? null,
      labels: Array.isArray(issue.labels) ? issue.labels : [],
      matches,
    };
  });

  if (args.json) {
    process.stdout.write(JSON.stringify({ cutoffIso, count: out.length, issues: out }, null, 2));
    process.stdout.write('\n');
  } else {
    console.log(`Cutoff (updatedAt) >= ${cutoffIso}`);
    console.log(`New issues: ${out.length}`);
    console.log('');

    for (const i of out) {
      console.log(`#${i.number} ${i.title}`);
      if (i.htmlUrl) console.log(`- issue: ${i.htmlUrl}`);
      if (i.updatedAt) console.log(`- updatedAt: ${i.updatedAt}`);
      if (i.labels?.length) console.log(`- labels: ${i.labels.join(', ')}`);
      if (!i.matches.length) {
        console.log(`- matches: (none)`);
      } else {
        console.log(`- matches:`);
        for (const m of i.matches) {
          console.log(`  - [${m.score}] ${m.slug} -> ${m.url}`);
        }
      }
      console.log('');
    }
  }

  if (!args.dryRun) {
    const nextState = {
      lastRunAt: new Date().toISOString(),
      processed: { ...(state.processed ?? {}) },
    };
    for (const i of newlySeen) {
      nextState.processed[String(i.number)] = i.updatedAt ?? new Date().toISOString();
    }
    await saveState(args.stateFile, nextState);
  }
}

main().catch((err) => {
  console.error(err?.stack || String(err));
  process.exit(1);
});
